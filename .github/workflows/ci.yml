name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main

env:
  REGISTRY: ghcr.io

jobs:
  cleanup:
    name: Cleanup Disk Space
    runs-on: self-hosted
    steps:
      - name: Free disk space
        run: |
          echo "Disk usage before cleanup:"
          df -h

          # Clean Docker resources
          docker system prune -af --volumes || true

          # Clean old Go cache
          sudo rm -rf /root/.cache/go-build || true
          sudo rm -rf $HOME/.cache/go-build || true

          # Clean apt cache
          sudo apt-get clean || true
          sudo rm -rf /var/lib/apt/lists/* || true

          # Clean old k3s data if exists
          sudo rm -rf /var/lib/rancher/k3s/agent/containerd/* || true

          echo "Disk usage after cleanup:"
          df -h

  test:
    name: Test
    runs-on: self-hosted
    needs: cleanup
    container:
      image: golang:1.25
      options: --user root
    steps:
      - name: Fix permissions
        run: |
          chmod -R 777 $GITHUB_WORKSPACE || true

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Node.js
        run: |
          apt-get update && apt-get install -y curl
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs

      - name: Setup dependencies
        run: |
          go mod tidy
          make tools

      - name: Build frontend
        run: |
          cd web && npm install && npm run build

      - name: Lint
        run: make lint

      - name: Test
        run: make test

      - name: Upload Coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./cover.out
          fail_ci_if_error: false

  build-operator:
    name: Build Operator Image
    runs-on: self-hosted
    needs: [cleanup, test]
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean workspace
        run: |
          sudo rm -rf $GITHUB_WORKSPACE/* || true
          sudo rm -rf $GITHUB_WORKSPACE/.* || true

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push operator image
        run: |
          TAGS="${{ steps.meta.outputs.tags }}"
          FIRST_TAG=$(echo "$TAGS" | head -n1)
          echo "Building with primary tag: $FIRST_TAG"
          IMG="$FIRST_TAG" make docker-buildx
          # Create additional tags using buildx imagetools
          echo "$TAGS" | while read -r tag; do
            if [ -n "$tag" ] && [ "$tag" != "$FIRST_TAG" ]; then
              echo "Creating tag: $tag"
              docker buildx imagetools create --tag "$tag" "$FIRST_TAG"
            fi
          done

  deploy-and-e2e:
    name: Deploy and E2E Test
    runs-on: self-hosted
    needs: build-operator
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      KUBECONFIG: /etc/rancher/k3s/k3s.yaml
      KUBECTL_FLAGS: --insecure-skip-tls-verify=true
    steps:
      - name: Clean workspace
        run: |
          sudo rm -rf $GITHUB_WORKSPACE/* || true
          sudo rm -rf $GITHUB_WORKSPACE/.* || true

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Install tools
        run: make tools

      - name: Uninstall k3s
        run: |
          if [ -x /usr/local/bin/k3s-uninstall.sh ]; then
            echo "Uninstalling k3s..."
            sudo /usr/local/bin/k3s-uninstall.sh || true
          fi
          # Wait for k3s to be fully uninstalled
          sleep 5

      - name: Install k3s
        run: |
          echo "Installing k3s..."
          curl -sfL https://get.k3s.io | sh -s - --write-kubeconfig-mode 644 || {
            echo "k3s installation failed, checking logs..."
            sudo journalctl -xeu k3s.service --no-pager -n 50
            sudo systemctl status k3s.service
            exit 1
          }

          # Wait for k3s to be ready
          echo "Waiting for k3s to be ready..."
          timeout=120
          while [ $timeout -gt 0 ]; do
            if sudo k3s kubectl get nodes 2>/dev/null | grep -q Ready; then
              echo "k3s node is ready"
              break
            fi
            echo "Waiting for k3s node... ($timeout seconds remaining)"
            sleep 5
            timeout=$((timeout - 5))
          done

          if [ $timeout -le 0 ]; then
            echo "k3s failed to become ready, checking status..."
            sudo systemctl status k3s.service
            sudo journalctl -xeu k3s.service --no-pager -n 100
            exit 1
          fi

          # Wait for core services
          sudo k3s kubectl wait --for=condition=available --timeout=120s \
            deployment/coredns -n kube-system

          echo "k3s is ready"

      - name: Install KubeVirt and CDI
        run: |
          # Install KubeVirt
          export KUBEVIRT_VERSION="v1.1.1"
          kubectl ${KUBECTL_FLAGS} apply -f "https://github.com/kubevirt/kubevirt/releases/download/${KUBEVIRT_VERSION}/kubevirt-operator.yaml"
          kubectl ${KUBECTL_FLAGS} apply -f "https://github.com/kubevirt/kubevirt/releases/download/${KUBEVIRT_VERSION}/kubevirt-cr.yaml"

          # Install CDI
          export CDI_VERSION="v1.58.0"
          kubectl ${KUBECTL_FLAGS} apply -f "https://github.com/kubevirt/containerized-data-importer/releases/download/${CDI_VERSION}/cdi-operator.yaml"
          kubectl ${KUBECTL_FLAGS} apply -f "https://github.com/kubevirt/containerized-data-importer/releases/download/${CDI_VERSION}/cdi-cr.yaml"

          # Wait for KubeVirt to be ready
          echo "Waiting for KubeVirt to be ready..."
          kubectl ${KUBECTL_FLAGS} wait --for=condition=available --timeout=300s \
            deployment/virt-operator -n kubevirt || true

          echo "KubeVirt and CDI installed"

      - name: Deploy operator to local cluster
        run: |
          # Install CRDs
          make install KUBECTL_FLAGS="${KUBECTL_FLAGS}"

          # Deploy operator with latest image
          IMG=ghcr.io/${{ github.repository }}:latest make deploy KUBECTL_FLAGS="${KUBECTL_FLAGS}"

          # Wait for deployment to be ready
          kubectl ${KUBECTL_FLAGS} wait --for=condition=available --timeout=300s \
            deployment/llmcloud-operator-controller-manager \
            -n llmcloud-operator-system

      - name: Run E2E tests
        env:
          USE_EXISTING_CLUSTER: "true"
          IMG: ghcr.io/${{ github.repository }}:latest
        run: |
          go test -v -tags=e2e ./test/e2e/... -timeout 30m

      - name: Collect logs on failure
        if: failure()
        run: |
          kubectl ${KUBECTL_FLAGS} get pods -n llmcloud-operator-system
          kubectl ${KUBECTL_FLAGS} get events -n llmcloud-operator-system --sort-by='.lastTimestamp'
          kubectl ${KUBECTL_FLAGS} describe pods -n llmcloud-operator-system
          kubectl ${KUBECTL_FLAGS} logs -n llmcloud-operator-system -l control-plane=controller-manager --tail=200

      - name: Cleanup
        if: always()
        run: |
          make undeploy KUBECTL_FLAGS="${KUBECTL_FLAGS}" || true
          make uninstall KUBECTL_FLAGS="${KUBECTL_FLAGS}" || true
          kubectl ${KUBECTL_FLAGS} delete namespace llmcloud-operator-system --timeout=60s || true

